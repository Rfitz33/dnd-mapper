<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D&D Map Gridder</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column; /* Changed from row to column */
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            overflow: hidden; /* Prevent body scrollbars */
        }

        .controls {
            background-color: #ddd;
            padding: 10px;
            display: flex;
            flex-wrap: wrap; /* Allow controls to wrap */
            align-items: center;
            gap: 15px;
            border-bottom: 1px solid #bbb;
        }

        .controls label,
        .controls button,
        .controls input {
            margin-right: 5px;
        }
        #rotationControls.hidden {
            display: none !important; /* Use important if needed to override inline-block */
        }
        /* Styling for the category container */
        .icon-categories {
            background-color: #eee;
            padding: 10px;
            border-bottom: 1px solid black;
            display: flex; /* Keep items in a row */
            gap: 10px;
            align-items: flex-start; /* Align tops of dropdowns */
            min-height: 50px;
            /* Allow horizontal scrolling if many categories */
            overflow-x: auto;
            /* Prevent vertical expansion if dropdowns open */
            max-height: 150px; /* Adjust as needed */
            overflow-y: hidden; /* Hide vertical scroll on main container */
        }

        /* Styling for each category dropdown */
        .icon-categories details {
            border: 1px solid #bbb;
            border-radius: 4px;
            background-color: #f9f9f9;
            max-height: 140px; /* Limit height when open */

        }

        .icon-categories summary {
            padding: 5px 30px 5px 10px;
            cursor: pointer;
            background-color: #e0e0e0;
            border-bottom: 1px solid #bbb; /* Separator when closed */
            list-style: none; /* Remove default triangle */
            position: relative; /* For custom arrow */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
         .icon-categories summary::-webkit-details-marker { display: none; } /* Hide default arrow (Chrome/Safari) */
         .icon-categories summary::marker { display: none; } /* Hide default arrow (Firefox) */

         /* Custom Arrow (Optional) */
         .icon-categories summary::after {
            content: ' ▼'; /* Down arrow when closed */
            font-size: 0.8em;
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
         }
         .icon-categories details[open] summary::after {
            content: ' ▲'; /* Up arrow when open */
         }


        /* Styling for the content area within the dropdown */
        .icon-categories .dropdown-content {
            display: flex;
            flex-wrap: wrap; /* Allow icons to wrap */
            gap: 8px; /* Spacing between icons */
            padding: 10px;
            max-height: 100px; /* Limit inner content height */
            overflow-y: auto; /* Allow scrolling WITHIN the dropdown */
            background-color: white; /* Background for icon area */
        }

        /* Styling for icons within the dropdown */
        .icon-categories .dropdown-content img {
            width: 30px;
            height: 30px;
            border: 1px solid #ccc; /* Lighter border inside */
            cursor: grab;
            background-color: white;
            box-shadow: 1px 1px 2px rgba(0,0,0,0.1); /* Subtle shadow */
        }

        .map-container {
            flex-grow: 1; /* Take remaining vertical space */
            position: relative; /* Needed for absolute positioning of canvas */
            overflow: hidden; /* Clip the canvas */
            background-color: black; /* Background if canvas is smaller */
            display: flex; /* Center canvas */
            justify-content: center; /* Center canvas */
            align-items: center; /* Center canvas */
        }

        canvas {
            border: 1px solid black;
            cursor: grab; /* Default cursor for panning */
            max-width: 100%;
            max-height: 100%;
            object-fit: contain; /* Ensure canvas itself fits container */
            background-color: white; /* Default background */
        }

        /* Hide scaling controls initially or after confirmation */
        .scaling-controls.hidden {
            display: none;
        }

        .context-menu {
            display: none;
            position: absolute;
            background-color: white;
            border: 1px solid black;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
            padding: 5px 0;
            z-index: 1000;
        }
        .context-menu button {
            display: block;
            width: 100%;
            padding: 5px 15px;
            border: none;
            background: none;
            text-align: left;
            cursor: pointer;
        }
        .context-menu button:hover {
            background-color: #eee;
        }
        /* Styles for the map container when in fullscreen */
        .map-container:fullscreen {
            /* Ensure it takes up the whole screen */
            width: 100vw;
            height: 100vh;
            /* Override any potential max-width/height from normal mode */
            max-width: none;
            max-height: none;
            /* Ensure background and centering are maintained */
            background-color: black;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0; /* Remove padding if any */
            margin: 0; /* Remove margin */
            border: none; /* Remove borders */
        }
        /* You might need vendor prefixes for older browser support */
        .map-container:-webkit-full-screen {
            width: 100vw;
            height: 100vh;
            max-width: none;
            max-height: none;
            background-color: black;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0; margin: 0; border: none;
        }
        .map-container:-moz-full-screen {
            width: 100vw;
            height: 100vh;
            max-width: none;
            max-height: none;
            background-color: black;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0; margin: 0; border: none;
        }
        .map-container:-ms-fullscreen {
            width: 100vw;
            height: 100vh;
            max-width: none;
            max-height: none;
            background-color: black;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0; margin: 0; border: none;
        }

        /* Ensure canvas within fullscreen container behaves */
        .map-container:fullscreen canvas {
            /* Allow canvas to grow to fit the fullscreen container via resizeCanvas logic */
            max-width: 100%;
            max-height: 100%;
        }
        .map-container:-webkit-full-screen canvas { max-width: 100%; max-height: 100%; }
        .map-container:-moz-full-screen canvas { max-width: 100%; max-height: 100%; }
        .map-container:-ms-fullscreen canvas { max-width: 100%; max-height: 100%; }

    </style>
</head>
<body>

    <div class="controls">
        <div>
            <label for="mapUpload">Upload Map:</label>
            <input type="file" id="mapUpload" accept="image/*">
        </div>
        <div style="border-left: 1px solid #bbb; padding-left: 10px;">
            <input type="checkbox" id="showGridCheckbox" checked>
            <label for="showGridCheckbox">Show Grid</label>
        </div>
        <div id="scalingControls" class="scaling-controls hidden">
            <label for="gridSizeSlider">Grid Size (pixels):</label>
            <input type="range" id="gridSizeSlider" min="10" max="200" value="50">
            <span id="gridSizeValue">50</span>px
            <div id="rotationControls" class="hidden" style="display: inline-block; margin-left: 15px;">
                <button id="rotateLeftButton" title="Rotate Counter-Clockwise">↶ Rotate</button>
                <button id="rotateRightButton" title="Rotate Clockwise">Rotate ↷</button>
           </div>
            <button id="confirmScaleAndRotationButton">Set Scale & Rotation</button>
            <p style="margin: 0 0 0 10px; font-size: 0.9em;">Adjust slider/rotation, then set.</p>
        </div>
        <div id="gridPanningControls" class="hidden" style="border-left: 1px solid #bbb; padding-left: 10px;"> <!-- Start hidden -->
            <p style="margin: 0 5px 0 0; font-size: 0.9em; display: inline;">Drag grid lines to align. </p>
            <button id="confirmGridPositionButton">Confirm Grid Position</button>
       </div>
         <div id="zoomControls" class="hidden"> <!-- Initially hidden -->
            <label for="zoomSlider">Zoom:</label>
            <input type="range" id="zoomSlider" min="0.1" max="5" step="0.1" value="1">
            <span id="zoomValue">1.0</span>x
        </div>
        <div>
            <label for="iconUpload">Add Icon:</label>
            <input type="file" id="iconUpload" accept="image/*">
        </div>
        <div>
            <button id="fullscreenButton">Enter Fullscreen</button>
        </div>
    </div>

    <div class="icon-categories" id="iconCategoriesContainer">
        <span>Icons:</span>
        <!-- Preset icons will be added here by JS -->
    </div>

    <div class="map-container">
        <canvas id="mapCanvas"></canvas>
        <!-- Context Menu for Icons -->
        <div id="iconContextMenu" class="context-menu">
            <button id="ctxMove">Move</button> <!-- Technically handled by drag, but could be explicit -->
            <button id="ctxMarkDead">Mark Dead/Alive</button>
            <button id="ctxRemove">Remove</button>
            <hr style="margin: 5px 0;"> <!-- Optional separator -->
            <button id="ctxSetSmall">Set Size: Small (Visual)</button>
            <button id="ctxSetMedium">Set Size: Medium (1x1)</button>
            <button id="ctxSetLarge">Set Size: Large (2x2)</button>
            <button id="ctxSetHuge">Set Size: Huge (3x3)</button>
            <button id="ctxSetGarg">Set Size: Gargantuan (4x4)</button>
            <hr style="margin: 5px 0;">
            <button id="ctxRotateCW">Rotate CW ↷</button>
            <button id="ctxRotateCCW">Rotate CCW ↶</button>
        </div>
    </div>

    <script>
        const mapUpload = document.getElementById('mapUpload');
        const iconUpload = document.getElementById('iconUpload');
        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');
        const gridSizeSlider = document.getElementById('gridSizeSlider');
        const gridSizeValue = document.getElementById('gridSizeValue');
        const showGridCheckbox = document.getElementById('showGridCheckbox'); // New element
        const confirmScaleAndRotateButton = document.getElementById('confirmScaleAndRotationButton'); // Renamed button
        const gridPanningControls = document.getElementById('gridPanningControls'); // New controls div
        const confirmGridPositionButton = document.getElementById('confirmGridPositionButton');
        const scalingControls = document.getElementById('scalingControls');
        const zoomControls = document.getElementById('zoomControls');
        const zoomSlider = document.getElementById('zoomSlider');
        const zoomValue = document.getElementById('zoomValue');
        console.log("zoomSlider element:", zoomSlider); //Log the zoomSlider element
        const mapContainer = document.querySelector('.map-container');
        const iconContextMenu = document.getElementById('iconContextMenu');
        const ctxMove = document.getElementById('ctxMove');
        const ctxMarkDead = document.getElementById('ctxMarkDead');
        const ctxRemove = document.getElementById('ctxRemove');
        const fullscreenButton = document.getElementById('fullscreenButton'); 
        const rotationControls = document.getElementById('rotationControls'); 
        const rotateLeftButton = document.getElementById('rotateLeftButton');
        const rotateRightButton = document.getElementById('rotateRightButton'); 


        let mapImage = null;
        let currentRotation = 0; // Add this: 0, 90, 180, 270 degrees
        let gridSize = 50; // Initial grid size in pixels (adjusts during scaling)
        // let isScaling = true; // Start in scaling mode
        let currentSetupStep = 'initial'; // 'initial', 'scaling', 'panningGrid', 'done'
        let isPanningGrid = false; // Specific state for grid panning
        let gridPanOffset = { x: 0, y: 0 }; // Offset for the grid itself
        let zoom = 1;
        let panOffset = { x: 0, y: 0 };
        let isPanning = false;
        let isDraggingIcon = false;
        let draggedIcon = null; // { img, src, x, y, gridX, gridY, id, isDead, isPaletteIcon, offsetX, offsetY }
        let selectedIconForContextMenu = null;
        let lastMousePos = { x: 0, y: 0 };
        let iconsOnMap = []; // { img, src, gridX, gridY, id, isDead }
        // Add a global lookup map
        let flatIconLookup = new Map(); // Map<src, iconDataObject>
        let availableIcons = { // Preset icons
            "Players": [
                { src: 'images/farrenF.png', img: null, name: 'Farren Tanglefoot' },
                { src: 'images/brorF.png', img: null, name: 'Bror' },
                { src: 'images/rylanF.png', img: null, name: 'Rylan' },
                { src: 'images/anakin.png', img: null, name: 'Anakin' },
                { src: 'images/tRookledust.png', img: null, name: 'Tatiana Rookledust' },
                { src: 'images/becklin.png', img: null, name: 'Becklin Uth Viharin' },
                { src: 'images/cudgelIronsmile.png', img: null, name: 'Cudgel Ironsmile' },
                { src: 'images/elgoDuckditcher.png', img: null, name: 'Kender Female' }

            ],
            "Creatures & NPCs": [
                { src: 'images/barkeep.png', img: null, name: 'Barkeep' },
                { src: 'images/dwarf.png', img: null, name: 'Dwarf' },
                { src: 'images/dwarfW.png', img: null, name: 'Dwarf Woman' },
                { src: 'images/gnome.png', img: null, name: 'Gnome' },
                { src: 'images/sorceror.png', img: null, name: 'Human Sorceror' },
                { src: 'images/oldWoman.png', img: null, name: 'Human Woman' },
                { src: 'images/halfling.png', img: null, name: 'Halfling Rogue' },
                { src: 'images/cleric.png', img: null, name: 'Halfling Cleric' },
                { src: 'images/desmondG.png', img: null, name: 'Desmond' },
                { src: 'images/desmondS.png', img: null, name: 'Desmond' },
                { src: 'images/guard.png', img: null, name: 'Guard' },
                { src: 'images/guard2.png', img: null, name: 'Guard' },
                { src: 'images/guard3.png', img: null, name: 'Guard' },
                { src: 'images/snake.png', img: null, name: 'Snake' },
                { src: 'images/wolf.png', img: null, name: 'Wolf' },
                { src: 'images/cat.png', img: null, name: 'Cat' },
                { src: 'images/ghOwlS.png', img: null, name: 'Owl' },
                { src: 'images/ghOwl.png', img: null, name: 'Owl' },
                { src: 'images/gEagleS.png', img: null, name: 'Giant Eagle' },
                { src: 'images/gEagleS.png', img: null, name: 'Giant Eagle' },
                { src: 'images/brownBear.png', img: null, name: 'Brown Bear' },
                { src: 'images/warhorse.png', img: null, name: 'Warhorse' },
                { src: 'images/giantFrog.png', img: null, name: 'Giant Frog' },
                { src: 'images/giantSpider.png', img: null, name: 'Giant Spider' },
                { src: 'images/giantHyena.png', img: null, name: 'Giant Hyena' },
                { src: 'images/giantOctopus.png', img: null, name: 'Giant Octopus' },
                { src: 'images/giantSeahorse.png', img: null, name: 'Giant Seahorse' }
            ],
            "Common Enemies:": [
                { src: 'images/elfBandit.png', img: null, name: 'Bandit' },
                { src: 'images/bandit1.png', img: null, name: 'Bandit with Crossbow' },
                { src: 'images/monster.png', img: null, name: 'Monster' },
                { src: 'images/ghoul.png', img: null, name: 'Ghoul' },
                { src: 'images/ghoul2.png', img: null, name: 'Ghoul' },
                { src: 'images/goblinMage.png', img: null, name: 'Goblin Mage' },
                { src: 'images/goblin2.png', img: null, name: 'Goblin Bandit' },
                { src: 'images/hobgoblinF.png', img: null, name: 'Hobgoblin Boss' },
                { src: 'images/hobgoblinCaptain.png', img: null, name: 'Hobgoblin Captain' },
                { src: 'images/hobgoblinFighter.png', img: null, name: 'Hobgoblin Fighter' },
                { src: 'images/hobgoblinFighter2.png', img: null, name: 'Hobgoblin Fighter' },
                { src: 'images/hobgoblinMage.png', img: null, name: 'Hobgoblin Mage' },
                { src: 'images/hobgoblinPaladin.png', img: null, name: 'Hobgoblin Paladin' },
                { src: 'images/hobgoblinRanger.png', img: null, name: 'Hobgoblin Ranger' }
            ],
            "Dragon Army": [
                { src: 'images/red_dragon.png', img: null, name: 'Red Dragon' },
                { src: 'images/redDragon.png', img: null, name: 'Red Dragon' },
                { src: 'images/greenDragon.png', img: null, name: 'Green Dragon' },
                { src: 'images/silverDragon.png', img: null, name: 'Silver Dragon' },
                { src: 'images/bronzeDragon.png', img: null, name: 'Bronze Dragon' },
                { src: 'images/deathDragon.png', img: null, name: 'Death Dragon' },
                { src: 'images/aurakF.png', img: null, name: 'Aurak Draconian' },
                { src: 'images/bozak.png', img: null, name: 'Bozak Draconian' },
                { src: 'images/bozak.gif', img: null, name: 'Bozak Draconian' },
                { src: 'images/sivakF.png', img: null, name: 'Sivak Draconian' },
                { src: 'images/kapakF.png', img: null, name: 'Kapak Draconian' },
                { src: 'images/daOfficer.png', img: null, name: 'Dragon Army Officer' },
                { src: 'images/daSoldier1.png', img: null, name: 'Dragon Army Soldier' },
                { src: 'images/daSoldier2.png', img: null, name: 'Dragon Army Soldier' },
                { src: 'images/daSorceror.png', img: null, name: 'Dragon Army Sorceror' },
                { src: 'images/lordSoth.png', img: null, name: 'Lord Soth' }
            ],
            "Kalaman Army": [
                { src: 'images/kSoldierH.png', img: null, name: 'Kalaman Soldier on Horseback' },
                { src: 'images/kSoldier1.png', img: null, name: 'Kalaman Soldier' },
                { src: 'images/kSoldier2.png', img: null, name: 'Kalaman Soldier' },
                { src: 'images/kSoldier3.png', img: null, name: 'Kalaman Soldier' },
            ], 
            "Objects and Traps": [
                { src: 'images/treasureChest.png', img: null, name: 'Gold Chest' },
                { src: 'images/potions.png', img: null, name: 'Potion Crate' },
                { src: 'images/armorLoot.png', img: null, name: 'Loot' },
                { src: 'images/goldLoot.png', img: null, name: 'Gold Bags' },
                { src: 'images/magicScrolls.png', img: null, name: 'Spellbooks & Scrolls' },
                { src: 'images/tavernFood.png', img: null, name: 'Food & Drinks' },
                { src: 'images/trapDoor.png', img: null, name: 'Trap Door' },
                { src: 'images/books.png', img: null, name: 'Books' },


            ]
        };
        let nextIconId = 0;
        let iconInstanceCounters = new Map();
        let skullImage = null;

        // --- Initialization ---

        function initialize() {
            resizeCanvas();
            loadPresetIcons();
            loadSkullImage();
            setupEventListeners();
            updatePalette();
            currentSetupStep = 'initial'; // Start at initial state
            updateControlVisibility(); // Function to show/hide controls based on state
            draw(); // Initial draw (empty)
        }

        function updateControlVisibility() {
            // Hide all step-specific controls initially
            scalingControls.classList.add('hidden');
            rotationControls.classList.add('hidden'); // Rotation is part of scaling step now
            gridPanningControls.classList.add('hidden');
            zoomControls.classList.add('hidden'); // Hide zoom/icons until done

            // Show controls based on the current step
            if (currentSetupStep === 'scaling') {
                scalingControls.classList.remove('hidden');
                rotationControls.classList.remove('hidden');
            } else if (currentSetupStep === 'panningGrid') {
                gridPanningControls.classList.remove('hidden');
                // Keep map panning enabled maybe? Or disable? Let's allow both for now.
            } else if (currentSetupStep === 'done') {
                zoomControls.classList.remove('hidden');
                // Icon palette interaction enabled implicitly when not scaling/panningGrid
            }
            // 'initial' state shows only upload button essentially
        }

        function resizeCanvas() {
            const containerWidth = mapContainer.clientWidth;
            const containerHeight = mapContainer.clientHeight;
            const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);

            console.log(`Resizing Canvas. Fullscreen: ${isFullscreen}, Container: ${containerWidth}x${containerHeight}`);


            if (isFullscreen && containerWidth > 0 && containerHeight > 0) {
                 // --- FULLSCREEN: Make canvas fill the container exactly ---
                 canvas.width = containerWidth;
                 canvas.height = containerHeight;
                 console.log(`Fullscreen Canvas Size: ${canvas.width}x${canvas.height}`);
                 // Note: We don't calculate initial zoom/pan here, that happens in handleFullscreenChange
            } else if (mapImage && containerWidth > 0 && containerHeight > 0) {
                // --- NORMAL MODE: Preserve map aspect ratio ---
                const { width: rotatedWidth, height: rotatedHeight } = getRotatedMapDimensions();
                if (rotatedWidth === 0 || rotatedHeight === 0) {
                    // Fallback if map dimensions are invalid
                    canvas.width = containerWidth * 0.95;
                    canvas.height = containerHeight * 0.95;
                    console.warn("Map dimensions invalid during resize.");
                } else {
                    const imageAspectRatio = rotatedWidth / rotatedHeight;
                    const containerAspectRatio = containerWidth / containerHeight;

                    if (imageAspectRatio > containerAspectRatio) {
                        canvas.width = containerWidth;
                        canvas.height = containerWidth / imageAspectRatio;
                    } else {
                        canvas.height = containerHeight;
                        canvas.width = containerHeight * imageAspectRatio;
                    }
                     console.log(`Normal Mode Canvas Size: ${canvas.width}x${canvas.height}`);
                }
            } else if (containerWidth > 0 && containerHeight > 0) {
                 // --- NO MAP LOADED: Default size ---
                 canvas.width = containerWidth * 0.95;
                 canvas.height = containerHeight * 0.95;
                 console.log(`No Map Canvas Size: ${canvas.width}x${canvas.height}`);
            } else {
                 console.warn("Container has zero dimensions during resize.");
                 // Avoid setting zero width/height which can cause issues
                 // canvas.width = 100; // Or some minimal default
                 // canvas.height = 100;
            }

            // We call draw explicitly after setting zoom/pan elsewhere (like handleFullscreenChange or centerMap)
            // to avoid drawing with potentially incorrect transforms right after resize.
            // draw(); // Maybe remove this immediate draw call? Let caller handle it.
        }

        function loadPresetIcons() {
            flatIconLookup.clear(); // Clear previous lookup data
            // Iterate through categories
            for (const category in availableIcons) {
                if (availableIcons.hasOwnProperty(category)) {
                    availableIcons[category].forEach(iconData => { // Use the category array
                        const img = new Image();
                        img.onload = () => {
                            iconData.img = img;
                            updatePalette(); // Update when image loads
                        };
                        img.onerror = () => {
                            console.error(`Failed to load preset icon: ${iconData.src}`);
                            // Remove or mark the icon as unloadable if needed
                            iconData.img = null; // Mark as failed
                            updatePalette(); // Update to remove/show failure?
                        };
                        img.src = iconData.src;
                        img.draggable = true; // Make palette icons draggable
                        img.dataset.iconSrc = iconData.src; // Store src for drag identification
                        // Populate the flat lookup map
                        if (!flatIconLookup.has(iconData.src)) {
                             flatIconLookup.set(iconData.src, iconData);
                        } else {
                             console.warn(`Duplicate icon src found: ${iconData.src}`);
                        }
                    });
                }
            }
            updatePalette();
        }
       
        function loadSkullImage() {
            skullImage = new Image();
            skullImage.onload = () => {
                console.log("Skull overlay image loaded.");
                // Optional: Call draw() here if you want an immediate redraw once it loads,
                // though it will redraw on next interaction anyway.
                // draw();
            };
            skullImage.onerror = () => {
                console.error("Failed to load skull.png overlay image.");
                skullImage = null; // Set back to null if loading fails
            };
            skullImage.src = 'images/skull.png'; 
        }

        function updatePalette() {
            const container = document.getElementById('iconCategoriesContainer');
            // Clear previous dropdowns (keep the "Icons:" span)
            const existingDetails = container.querySelectorAll('details');
            existingDetails.forEach(details => details.remove());

            // Build dropdowns for each category
            for (const category in availableIcons) {
                if (availableIcons.hasOwnProperty(category)) {
                    const iconsInCategory = availableIcons[category];

                    // Create <details> and <summary> elements
                    const detailsElement = document.createElement('details');
                    const summaryElement = document.createElement('summary');
                    summaryElement.textContent = category; // Category name
                    detailsElement.appendChild(summaryElement);

                    // Create content div for icons
                    const contentElement = document.createElement('div');
                    contentElement.className = 'dropdown-content';

                    // Add loaded icons to the content div
                    iconsInCategory.forEach(iconData => {
                        if (iconData.img) { // Only add if image is loaded
                            const imgElement = iconData.img.cloneNode();
                            imgElement.style.width = '30px';
                            imgElement.style.height = '30px';
                            imgElement.style.border = '1px solid #ccc';
                            imgElement.style.cursor = 'grab';
                            imgElement.draggable = true;
                            imgElement.dataset.iconSrc = iconData.src;
                            imgElement.title = iconData.name || category; // Tooltip
                            contentElement.appendChild(imgElement);

                            // Add drag listener
                            imgElement.addEventListener('dragstart', handlePaletteDragStart);
                        }
                         // Optional: Add placeholder or text for failed icons?
                         // else if (iconData.img === null && iconData.src) { // Check if load failed
                         //    const failedText = document.createElement('span');
                         //    failedText.textContent = `❗ ${iconData.name || iconData.src}`;
                         //    failedText.title = `Failed to load ${iconData.src}`;
                         //    failedText.style.fontSize = '0.8em';
                         //    contentElement.appendChild(failedText);
                         // }
                    });

                    // Only add the dropdown if it contains icons
                    if (contentElement.hasChildNodes()) {
                        detailsElement.appendChild(contentElement);
                        container.appendChild(detailsElement);
                    }
                }
            }
        }


        // --- Event Listeners ---

        function setupEventListeners() {
            window.addEventListener('resize', resizeCanvas);
            mapUpload.addEventListener('change', handleMapUpload);
            iconUpload.addEventListener('change', handleIconUpload);
            gridSizeSlider.addEventListener('input', handleGridSizeChange);
            showGridCheckbox.addEventListener('change', draw); // Redraw when checkbox changes
            confirmScaleAndRotateButton.addEventListener('click', handleConfirmScaleAndRotate); // New handler
            confirmGridPositionButton.addEventListener('click', handleConfirmGridPosition); // New handler
            zoomSlider.addEventListener('input', handleZoomChange);
            // --- ADD Check for zoomSlider ---
            if (zoomSlider) {
                zoomSlider.addEventListener('input', handleZoomChange); // Add listener only if element exists
            } else {
                console.error("Zoom slider element not found during setup!");
            }
            rotateLeftButton.addEventListener('click', handleRotateLeft);
            rotateRightButton.addEventListener('click', handleRotateRight);

            // Keyboard zoom
            window.addEventListener('keydown', handleKeyDown);

            // Canvas interactions
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseLeave); // Stop panning/dragging if mouse leaves
            canvas.addEventListener('wheel', handleWheelZoom, { passive: false }); // Use wheel for zooming
            canvas.addEventListener('dragover', handleDragOver); // Needed for dropping
            canvas.addEventListener('drop', handleDrop); // Handle dropping palette icons
            canvas.addEventListener('contextmenu', handleContextMenu); // Right-click

            // Context Menu Buttons
            iconContextMenu.addEventListener('click', handleContextMenuClick); // Use event delegation or individual listeners
            document.addEventListener('click', hideContextMenu); // Hide menu if clicking elsewhere
            fullscreenButton.addEventListener('click', toggleFullScreen);
            document.addEventListener('fullscreenchange', handleFullscreenChange);
            // Add vendor specific listeners too if needed for older browsers
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.addEventListener('mozfullscreenchange', handleFullscreenChange);
            document.addEventListener('MSFullscreenChange', handleFullscreenChange);
        }
        // --- Fullscreen Functions ---

        function toggleFullScreen() {
            if (!document.fullscreenElement &&
                !document.mozFullScreenElement && // Firefox
                !document.webkitFullscreenElement && // Chrome, Safari & Opera
                !document.msFullscreenElement) { // IE/Edge
                // Enter fullscreen
                if (mapContainer.requestFullscreen) {
                    mapContainer.requestFullscreen();
                } else if (mapContainer.mozRequestFullScreen) { // Firefox
                    mapContainer.mozRequestFullScreen();
                } else if (mapContainer.webkitRequestFullscreen) { // Chrome, Safari & Opera
                    mapContainer.webkitRequestFullscreen();
                } else if (mapContainer.msRequestFullscreen) { // IE/Edge
                    mapContainer.msRequestFullscreen();
                }
            } else {
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) { // Firefox
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) { // Chrome, Safari & Opera
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { // IE/Edge
                    document.msExitFullscreen();
                }
            }
        }

        function handleFullscreenChange() {
            const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);

            // Resize canvas dimensions IMMEDIATELY to potentially help layout
            resizeCanvas();

            if (isFullscreen) {
                fullscreenButton.textContent = 'Exit Fullscreen';
                console.log("Entered fullscreen. Canvas resized.");

                // Use setTimeout to delay calculations/drawing slightly
                setTimeout(() => {
                    console.log("Timeout: Processing fullscreen entry drawing.");

                    if (mapImage) {
                        // Calculate Fill Zoom and Center Pan using current canvas dimensions
                        const { width: rotatedWidth, height: rotatedHeight } = getRotatedMapDimensions();
                        const screenWidth = canvas.width; // Read latest size
                        const screenHeight = canvas.height;

                        if (rotatedWidth > 0 && rotatedHeight > 0 && screenWidth > 0 && screenHeight > 0) {
                            const mapAspect = rotatedWidth / rotatedHeight;
                            const screenAspect = screenWidth / screenHeight;

                            let fillZoom;
                            if (mapAspect >= screenAspect) { // Fit height
                                fillZoom = screenHeight / rotatedHeight;
                            } else { // Fit width
                                fillZoom = screenWidth / rotatedWidth;
                            }

                            zoom = fillZoom;
                            zoomSlider.value = zoom;
                            zoomValue.textContent = zoom.toFixed(2);

                            panOffset.x = (screenWidth - rotatedWidth * zoom) / 2;
                            panOffset.y = (screenHeight - rotatedHeight * zoom) / 2;

                            console.log(`Timeout: Fill Zoom: ${zoom}, Pan: ${panOffset.x}, ${panOffset.y}`);

                        } else {
                            console.warn("Timeout: Cannot calculate fill zoom - invalid dimensions.");
                            zoom = 1;
                            zoomSlider.value = 1;
                            zoomValue.textContent = '1.0';
                            centerMap();
                        }
                    } else { // No map loaded
                        zoom = 1;
                        panOffset = { x: 0, y: 0 };
                    }

                    // Draw the initial fullscreen view *inside* timeout
                    console.log("Timeout: Calling draw() for fullscreen entry.");
                    draw();
                }, 10); // Delay by 10 milliseconds (adjust if needed)

            } else { // Exiting fullscreen
                fullscreenButton.textContent = 'Enter Fullscreen';
                 console.log("Exited fullscreen. Canvas resized."); // resize already happened above

                 // Use setTimeout for exit consistency
                 setTimeout(() => {
                    console.log("Timeout: Processing fullscreen exit drawing.");
                    centerMap(); // Recenter
                    console.log("Timeout: Calling draw() for fullscreen exit.");
                    draw(); // Draw restored view
                 }, 10); // Delay by 10 milliseconds
            }
        }

        function handleMapUpload(event) {
            const file = event.target.files[0];
            if (file && file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    mapImage = new Image();
                    mapImage.onload = () => {
                        console.log("Map image loaded:", mapImage.width, mapImage.height);
                        // Reset state for new map
                        isScaling = true;
                        gridPanOffset = { x: 0, y: 0 }; // Reset grid pan
                        currentRotation = 0; // Reset rotation
                        zoom = 1; // Reset zoom
                        panOffset = { x: 0, y: 0 }; // Reset pan
                        iconsOnMap = []; // Clear icons
                        scalingControls.classList.remove('hidden');
                        rotationControls.classList.remove('hidden'); // Show rotation buttons
                        zoomControls.classList.add('hidden');
                        gridSizeSlider.value = 50; // Reset grid slider
                        gridSizeValue.textContent = 50;
                        gridSize = 50;
                        showGridCheckbox.checked = true; // Default grid to visible
                        zoomSlider.value = 1; // Reset zoom slider
                        zoomValue.textContent = '1.0';

                        currentSetupStep = 'scaling'; // Go to scaling step
                        updateControlVisibility(); // Update UI

                        resizeCanvas(); // Resize canvas based on new image (will use rotation=0)
                        centerMap(); // Center the map (will use zoom=1 initially)
                        draw(); // Draw the newly loaded map
                    };
                    mapImage.onerror = () => {
                        alert("Error loading map image.");
                        mapImage = null;
                    }
                    mapImage.src = e.target.result;
                }
                reader.readAsDataURL(file);
            } else {
                alert("Please select a valid image file.");
            }
        }

        function handleIconUpload(event) {
            const file = event.target.files[0];
            if (file && file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const newIconSrc = e.target.result; // This is a data URL

                    // Check if already exists by src (data URL can be long)
                    if (flatIconLookup.has(newIconSrc)) return; // Already added

                    const img = new Image();
                    img.onload = () => {
                         const iconData = {
                             src: newIconSrc, // Use data URL as src
                             img: img,
                             name: file.name.replace(/\.[^/.]+$/, "") // Use filename without extension
                         };

                         // Add to a default category or create one
                         const uploadCategory = "Uploaded Icons";
                         if (!availableIcons[uploadCategory]) {
                             availableIcons[uploadCategory] = [];
                         }
                         availableIcons[uploadCategory].push(iconData);

                         // Add to flat lookup
                         flatIconLookup.set(iconData.src, iconData);

                         updatePalette(); // Refresh the UI
                    };
                     img.onerror = () => alert("Error loading uploaded icon image.");
                    img.src = newIconSrc;
                }
                reader.readAsDataURL(file);
            } else {
                alert("Please select a valid image file for the icon.");
            }
        }

        function handleGridSizeChange() {
            if (currentSetupStep !== 'scaling' || !mapImage) return;
            gridSize = parseInt(gridSizeSlider.value, 10);
            gridSizeValue.textContent = gridSize;
            draw();
        }

        function handleZoomChange() {
            // Check if setup is done before allowing zoom via slider
            if (currentSetupStep !== 'done') return; // Prevent zooming before grid is confirmed

            const newZoom = parseFloat(zoomSlider.value);
            // applyZoom already calls draw, so no extra draw() needed here
            applyZoom(newZoom); // applyZoom internally calls draw()
            zoomValue.textContent = newZoom.toFixed(1);
        }

        function handleKeyDown(event) {
            // Only allow zoom/pan keys when setup is done
            if (currentSetupStep !== 'done') return;

            let zoomChanged = false;
            let newZoom = zoom;

            if (event.key === 'ArrowLeft') {
                newZoom = Math.max(0.1, zoom - 0.1);
                zoomChanged = true;
            } else if (event.key === 'ArrowRight') {
                newZoom = Math.min(5, zoom + 0.1);
                zoomChanged = true;
            } else if(event.key === 'ArrowUp') {
                panOffset.y += 20; needsDraw = true;
            } else if(event.key === 'ArrowDown') {
                panOffset.y -= 20; needsDraw = true;
            } else if(event.key === 'ArrowLeft' && !zoomChanged) {
                panOffset.x += 20; needsDraw = true; // Pan if not zooming
            } else if(event.key === 'ArrowRight' && !zoomChanged) {
                panOffset.x -= 20; needsDraw = true;
            }   

            if (zoomChanged && newZoom !== zoom) {
                applyZoom(newZoom); // applyZoom calls draw()
                if(zoomSlider) zoomSlider.value = newZoom; // Update slider if it exists
                zoomValue.textContent = newZoom.toFixed(1);
            }
            // Add redraw for panning if implemented:
            else if (needsDraw) { draw(); }
        }

        function handleRotateLeft() {
            if (currentSetupStep !== 'scaling' || !mapImage) return;
            currentRotation = (currentRotation - 90 + 360) % 360; // Rotate CCW
            console.log("Rotated Left. New angle:", currentRotation);
            onRotationChange();
        }

        function handleRotateRight() {
            if (currentSetupStep !== 'scaling' || !mapImage) return;
            currentRotation = (currentRotation + 90) % 360; // Rotate CW
             console.log("Rotated Right. New angle:", currentRotation);
            onRotationChange();
        }

        function onRotationChange() {
            // Rotation changes effective dimensions, so resize canvas and recenter
            resizeCanvas();
            centerMap();
            draw();
        }

            
        function handleConfirmScaleAndRotate() {
            if (currentSetupStep !== 'scaling' || !mapImage) return;

            console.log(`Scale set to ${gridSize}px, Rotation set to ${currentRotation}deg.`);
            currentSetupStep = 'panningGrid'; // Move to next step
            // isPanningGrid = true; // REMOVE THIS LINE - Let mousedown handle starting the pan
            updateControlVisibility(); // Update UI
            draw(); // Redraw to show grid panning info maybe
        }

        function handleConfirmGridPosition() {
            if (currentSetupStep !== 'panningGrid' || !mapImage) return;

            console.log(`Grid position confirmed with offset:`, gridPanOffset);
            isPanningGrid = false; // Disable grid panning flag
            currentSetupStep = 'done'; // Setup finished
            updateControlVisibility(); // Update UI (show zoom controls)
            draw(); // Final redraw
        }

        function getRotatedMapDimensions() {
            if (!mapImage) return { width: 0, height: 0 };
            const isSideways = currentRotation === 90 || currentRotation === 270;
            return {
                width: isSideways ? mapImage.height : mapImage.width,
                height: isSideways ? mapImage.width : mapImage.height
            };
        }

        // Helper function to center the map view (using current zoom)
        function centerMap() {
             if (!mapImage) return;
             const { width: rotatedWidth, height: rotatedHeight } = getRotatedMapDimensions();

             // Check for valid dimensions before calculating offset
             if (canvas.width > 0 && canvas.height > 0 && rotatedWidth > 0 && rotatedHeight > 0) {
                 // Calculate pan to center the *rotated* map within the current canvas size at the current zoom
                 panOffset = {
                     x: (canvas.width - rotatedWidth * zoom) / 2,
                     y: (canvas.height - rotatedHeight * zoom) / 2
                 };
                  console.log(`Centered Map. Zoom: ${zoom}, Pan: ${panOffset.x}, ${panOffset.y}`);
             } else {
                  console.warn("Cannot center map - invalid dimensions.");
                  panOffset = { x: 0, y: 0 }; // Reset pan if centering fails
             }
        }

        function handleMouseMove(event) {
            if (!mapImage) return;
            // console.log("--- handleMouseMove START ---"); // Very verbose log
            const currentMousePos = getMousePos(canvas, event);
            const dx = currentMousePos.x - lastMousePos.x;
            const dy = currentMousePos.y - lastMousePos.y;

            if (isPanningGrid) {
                // console.log("MouseMove: Panning Grid"); // Verbose log
                gridPanOffset.x += dx;
                gridPanOffset.y += dy;
                draw();
            } else if (isPanning) {
                 // console.log("MouseMove: Panning Map"); // Verbose log
                 panOffset.x += dx;
                 panOffset.y += dy;
                 draw();
            } else if (isDraggingIcon && draggedIcon) {
                // console.log("MouseMove: Dragging Icon"); // Verbose log
                draggedIcon.x = currentMousePos.x - draggedIcon.offsetX;
                draggedIcon.y = currentMousePos.y - draggedIcon.offsetY;
                draw();
            }

            lastMousePos = currentMousePos;

            // Update cursor style
            if (isPanningGrid) {
                canvas.style.cursor = 'move';
            } else if (isDraggingIcon) {
                canvas.style.cursor = 'grabbing';
            } else if (isPanning) {
                canvas.style.cursor = 'grabbing';
            } else { // Default or hovering
                let cursorStyle = 'grab'; // Default map panning cursor
                if (currentSetupStep === 'done') { // Only check icon hover when setup is done
                    const iconUnderMouse = getIconAtScreenPos(currentMousePos.x, currentMousePos.y);
                    if (iconUnderMouse) { cursorStyle = 'grab'; }
                } else if (currentSetupStep === 'scaling'){
                     cursorStyle = 'grab'; // Allow map panning
                } else {
                     cursorStyle = 'default'; // Maybe default cursor if nothing else active
                }
                canvas.style.cursor = cursorStyle;
            }
        }

        function handleMouseUp(event) {
            console.log("--- handleMouseUp START ---");
            if (!mapImage) { /* ... exit ... */ }
            let stateChanged = false;
            const currentDraggedIconData = draggedIcon;
            const wasDraggingIcon = isDraggingIcon;
            const wasPanningGrid = isPanningGrid;

            if (isPanning) { isPanning = false; }
            if (isPanningGrid) { isPanningGrid = false; stateChanged = true; }

            if (wasDraggingIcon && currentDraggedIconData && currentDraggedIconData.id && currentSetupStep === 'done') {
                console.log("MouseUp: Handling end of VALID icon drag. Icon ID:", currentDraggedIconData.id);
                stateChanged = true;
                const currentMousePos = getMousePos(canvas, event);

                let gridX = null, gridY = null;
                let gridCalcSuccess = false; // Flag to check calculation result
                try {
                    const gridResult = screenToGrid(currentMousePos.x, currentMousePos.y);
                    gridX = gridResult.gridX;
                    gridY = gridResult.gridY;
                    // Check if BOTH are valid numbers (not null, not undefined)
                    if (typeof gridX === 'number' && typeof gridY === 'number') {
                        gridCalcSuccess = true;
                    }
                    console.log(`MouseUp: screenToGrid result: {gridX: ${gridX}, gridY: ${gridY}}, Success: ${gridCalcSuccess}`); // Log success flag
                } catch (error) {
                    console.error("MouseUp: Error in screenToGrid:", error);
                    gridCalcSuccess = false; // Ensure it's false on error
                }

                // --- Modified Logic ---
                if (gridCalcSuccess) { // Use the success flag
                    console.log(`MouseUp: Placing icon in valid grid (${gridX}, ${gridY})`);
                    const iconDataToPlace = {
                        id: currentDraggedIconData.id, src: currentDraggedIconData.src, img: currentDraggedIconData.img,
                        gridX: gridX, gridY: gridY, isDead: currentDraggedIconData.isDead,
                        instanceNumber: currentDraggedIconData.instanceNumber, size: currentDraggedIconData.size,
                        iconRotation: currentDraggedIconData.iconRotation, creatureSizeCategory: currentDraggedIconData.creatureSizeCategory
                    };
                    console.log(`MouseUp: Pushing icon back. Current length: ${iconsOnMap.length}`);
                    iconsOnMap.push(iconDataToPlace);
                    console.log(`MouseUp: Pushed icon. New length: ${iconsOnMap.length}`);
                } else { // Restore if grid calc failed OR returned null
                    console.log("MouseUp: screenToGrid failed or returned null. Attempting restore.");
                    // Check if original position data exists before restoring
                    if (currentDraggedIconData.originalGridX !== undefined && currentDraggedIconData.originalGridY !== undefined) {
                        const iconToRestore = {
                            id: currentDraggedIconData.id, src: currentDraggedIconData.src, img: currentDraggedIconData.img,
                            gridX: currentDraggedIconData.originalGridX, gridY: currentDraggedIconData.originalGridY,
                            isDead: currentDraggedIconData.isDead, instanceNumber: currentDraggedIconData.instanceNumber,
                            size: currentDraggedIconData.size, iconRotation: currentDraggedIconData.iconRotation,
                            creatureSizeCategory: currentDraggedIconData.creatureSizeCategory
                        };
                        console.log(`MouseUp: Restoring icon. Current length: ${iconsOnMap.length}`);
                        iconsOnMap.push(iconToRestore);
                        console.log(`MouseUp: Restored icon. New length: ${iconsOnMap.length}`);
                    } else {
                        console.warn("MouseUp: Cannot restore - original position data missing on draggedIcon.", currentDraggedIconData);
                        // Icon is lost if restore fails!
                    }
                }
                // --- End Modified Logic ---

                console.log("MouseUp: Resetting icon dragging state variables.");
                isDraggingIcon = false;
                draggedIcon = null;

            } else if (wasDraggingIcon) { /* ... Safety cleanup ... */ }

            // ... (Cursor reset, final draw call) ...
            if (!isPanning && !isDraggingIcon && !wasPanningGrid) { /* ... */ }
            else { /* ... */ }
            if (stateChanged) { draw(); }
            console.log("--- handleMouseUp END ---");
        }

        function handleMouseDown(event) {
            hideContextMenu();
            if (!mapImage) return;
            lastMousePos = getMousePos(canvas, event);
            console.log(`--- handleMouseDown START --- Step: ${currentSetupStep}, Button: ${event.button}`); // LOG

            // --- Reset Interaction Flags ---
            // Reset flags at the start of ANY mousedown to prevent stale states
            isPanning = false;
            isPanningGrid = false;
            isDraggingIcon = false;
            // draggedIcon = null; // Don't null draggedIcon here, mouseup needs it

            if (event.button === 0) { // --- LEFT MOUSE BUTTON ---
                if (currentSetupStep === 'panningGrid') {
                    console.log("MouseDOWN (Left): Setting isPanningGrid = true"); // LOG
                    isPanningGrid = true;
                    canvas.style.cursor = 'move';
                } else if (currentSetupStep === 'done') {
                    const clickedIcon = getIconAtScreenPos(lastMousePos.x, lastMousePos.y);
                    if (clickedIcon && clickedIcon.id) { // Check if icon found AND has an ID
                         console.log("MouseDOWN (Left): Starting icon drag for", clickedIcon.id); // LOG
                         isDraggingIcon = true; // Set flag HERE
                         draggedIcon = { // Prepare draggedIcon object HERE
                             ...clickedIcon,
                             originalGridX: clickedIcon.gridX,
                             originalGridY: clickedIcon.gridY,
                             isPaletteIcon: false
                         };
                         const iconScreenPos = gridToScreen(clickedIcon.gridX, clickedIcon.gridY);
                         draggedIcon.offsetX = lastMousePos.x - iconScreenPos.x;
                         draggedIcon.offsetY = lastMousePos.y - iconScreenPos.y;
                         canvas.style.cursor = 'grabbing';
                         iconsOnMap = iconsOnMap.filter(icon => icon.id !== clickedIcon.id); // Remove temporarily
                         draw(); // Redraw WITHOUT the icon that's being dragged
                    } else {
                         console.log("MouseDOWN (Left): Setting isPanning = true (Map Pan)"); // LOG
                         isPanning = true; // Set map panning flag
                         canvas.style.cursor = 'grabbing';
                    }
                } else if (currentSetupStep === 'scaling') {
                     console.log("MouseDOWN (Left): Setting isPanning = true (Map Pan during scaling)"); // LOG
                     isPanning = true; // Set map panning flag
                     canvas.style.cursor = 'grabbing';
                } else {
                    console.log("MouseDOWN (Left): No action for current step:", currentSetupStep); // LOG
                }
            } else if (event.button === 2) { // --- RIGHT MOUSE BUTTON ---
                 console.log("MouseDOWN (Right): No drag action initiated."); // LOG
                 // Do NOT set any drag/pan flags here. Context menu handled by 'contextmenu' event.
            }
             console.log(`--- handleMouseDown END --- Panning: ${isPanning}, GridPanning: ${isPanningGrid}, IconDragging: ${isDraggingIcon}`); // LOG
        }

        function handleMouseLeave(event) {
            // Check if the left mouse button is potentially pressed while leaving
            // Note: event.buttons is more reliable than event.which
            const isLeftButtonDown = event.buttons === 1; // 1 means left button is down

            // Stop panning ONLY if mouse leaves canvas AND button is STILL down
            if (isPanning && isLeftButtonDown) {
                console.log("MouseLeave: Stopping panning because mouse left while button down.");
                isPanning = false;
                // Cursor will be reset by mouseup later if button comes up over canvas,
                // or stays 'grabbing' until interaction ends if button comes up outside.
                // We could potentially reset cursor to 'grab' here if needed, but let's hold off.
            }

            // Stop/Cancel icon drag ONLY if NOT scaling AND button is STILL down
            if (isDraggingIcon && !isScaling && isLeftButtonDown) {
                console.log("MouseLeave: Cancelling drag because mouse left while button down.");
                // Restore icon if it was from the map
                if(draggedIcon && draggedIcon.originalGridX !== undefined) {
                    const iconToRestore = {
                        id: draggedIcon.id, src: draggedIcon.src, img: draggedIcon.img,
                        gridX: draggedIcon.originalGridX, gridY: draggedIcon.originalGridY,
                        isDead: draggedIcon.isDead, instanceNumber: draggedIcon.instanceNumber,
                        size: draggedIcon.size, // Ensure size is preserved
                        iconRotation: draggedIcon.iconRotation,
                        creatureSizeCategory: currentDraggedIconData.creatureSizeCategory 
                    };
                    iconsOnMap.push(iconToRestore);
                }
                isDraggingIcon = false; // Reset state as drag is cancelled
                draggedIcon = null;
                canvas.style.cursor = 'grab'; // Reset cursor as drag is cancelled
                draw(); // Redraw to show restored/removed icon
            }
            // No explicit 'else' needed here - if the button is UP when leaving,
            // we assume handleMouseUp already did or will do the necessary cleanup.
        }

        function handleWheelZoom(event) {
            if (!mapImage || isScaling) return;
            event.preventDefault(); // Prevent page scrolling

            const zoomFactor = 1.1;
            const mousePos = getMousePos(canvas, event);
            let newZoom;

            if (event.deltaY < 0) {
                // Zoom in
                newZoom = Math.min(5, zoom * zoomFactor);
            } else {
                // Zoom out
                newZoom = Math.max(0.1, zoom / zoomFactor);
            }

            if (newZoom !== zoom) {
                applyZoom(newZoom, mousePos); // Pass mousePos for centered zoom
                zoomSlider.value = newZoom;
                zoomValue.textContent = newZoom.toFixed(1);
            }
        }

        function applyZoom(newZoom, zoomCenter = null) {
            if (!mapImage) return;

             // Default zoom center to canvas center if not provided
             if (!zoomCenter) {
                 zoomCenter = { x: canvas.width / 2, y: canvas.height / 2 };
             }

             // Calculate world coordinates under the mouse cursor BEFORE zoom
             const worldPos = screenToWorld(zoomCenter.x, zoomCenter.y);

            zoom = newZoom;

             // Calculate where the world coordinate should be AFTER zoom and adjust pan
             // newScreenPos = worldToScreen(worldPos.x, worldPos.y)
             // We want newScreenPos to be equal to zoomCenter.
             // zoomCenter.x = (worldPos.x * zoom) + panOffset.x
             // zoomCenter.y = (worldPos.y * zoom) + panOffset.y
             // So, panOffset.x = zoomCenter.x - (worldPos.x * zoom)
             // And panOffset.y = zoomCenter.y - (worldPos.y * zoom)

             panOffset.x = zoomCenter.x - (worldPos.x * zoom);
             panOffset.y = zoomCenter.y - (worldPos.y * zoom);


            draw();
        }


        function handlePaletteDragStart(event) {
            const iconSrc = event.target.dataset.iconSrc;
            const iconData = flatIconLookup.get(iconSrc);
            if (!iconData || !iconData.img) {
                 console.error("DragStart: Could not find icon data or image for src:", iconSrc);
                 event.preventDefault(); // Prevent dragging bad data
                 return;
            }
            console.log("DragStart: Setting data for:", iconSrc);
            event.dataTransfer.setData('text/plain', iconSrc);
            event.dataTransfer.effectAllowed = 'copy';

            // --- RE-ADD Global State Setting ---
             draggedIcon = { // Prepare placeholder state
                 src: iconData.src,
                 img: iconData.img,
                 isPaletteIcon: true, // Mark as from palette
                 offsetX: 15,
                 offsetY: 15
             };
             isDraggingIcon = true; // Set flag
            // --- End Re-add ---

            console.log("DragStart: Started dragging icon from palette:", iconSrc);
        }

        function handleDragOver(event) {
            // Revert to checking the global state set by palette drag start
             if (isDraggingIcon && draggedIcon && draggedIcon.isPaletteIcon && currentSetupStep === 'done') {
                // console.log("DragOver: Allowing drop (isDraggingIcon check)"); // Verbose
                event.preventDefault(); // Allow drop ONLY if dragging from palette AND setup done
                event.dataTransfer.dropEffect = 'copy';
             } else {
                 // console.log("DragOver: Denying drop"); // Verbose
                 event.dataTransfer.dropEffect = 'none'; // Default deny
             }
        }

        function handleDrop(event) {
            console.log("--- handleDrop START ---"); // LOG Start
            event.preventDefault();
             if (currentSetupStep !== 'done') {
                 console.log("Drop ignored: Setup not complete.");
                 return;
             }

            const iconSrc = event.dataTransfer.getData('text/plain');
            console.log("Drop: Received iconSrc:", iconSrc);
            const iconData = flatIconLookup.get(iconSrc);

            if (iconData && iconData.img) {
                 console.log("Drop: Found iconData:", iconData);
                 const dropPos = getMousePos(canvas, event);
                 console.log("Drop: Mouse Pos:", dropPos);

                 let gridX = null, gridY = null;
                 try {
                     const gridResult = screenToGrid(dropPos.x, dropPos.y);
                     gridX = gridResult.gridX; gridY = gridResult.gridY;
                     console.log("Drop: screenToGrid result:", {gridX, gridY});
                 } catch(e) { /* ... error handling ... */ return; }

                if (gridX !== null && gridY !== null) {
                    let instanceNumber = 0;
                    let currentCount = iconInstanceCounters.get(iconData.src) || 0;
                    currentCount++;
                    instanceNumber = currentCount;
                    iconInstanceCounters.set(iconData.src, currentCount);
                    console.log(`Assigning number ${instanceNumber} to icon src: ${iconData.src}`);

                    // --- Generate ID cleanly BEFORE creating object ---
                    const newIconId = `icon-${nextIconId}`; // Get current ID part
                    nextIconId++; // Increment counter AFTER getting the value

                    // --- Place the new icon ---
                    const newIcon = {
                        id: newIconId, // Assign the generated ID
                        src: iconData.src,
                        img: iconData.img,
                        gridX: gridX,
                        gridY: gridY,
                        isDead: false,
                        instanceNumber: instanceNumber,
                        size: 1,
                        iconRotation: 0,
                        creatureSizeCategory: 'Medium'
                    };
                    iconsOnMap.push(newIcon);
                    console.log("Placed new icon:", newIcon); // Log the object

                } else { console.log("Icon dropped outside valid grid area."); }
            } else { console.error(`Drop: Dropped item src not found or image not loaded: ${iconSrc}`); }

            // Reset dragging state - Important to clear palette drag state
            console.log("Drop: Resetting drag state");
            isDraggingIcon = false; // Crucial reset
            draggedIcon = null;     // Crucial reset
            draw();
            console.log("--- handleDrop END ---");
        }

        function handleContextMenu(event) {
            console.log("--- handleContextMenu START ---"); // ADD THIS LOG
            event.preventDefault(); // Prevent browser's default context menu
            if (currentSetupStep !== 'done') { // Only allow context menu when setup is done
                console.log("Context menu ignored: Setup not complete.");
                return;
            }

            const mousePos = getMousePos(canvas, event);
            selectedIconForContextMenu = getIconAtScreenPos(mousePos.x, mousePos.y);

            if (selectedIconForContextMenu) {
                positionContextMenu(event.clientX, event.clientY);
                // Update menu item text based on state
                ctxMarkDead.textContent = selectedIconForContextMenu.isDead ? 'Mark Alive' : 'Mark Dead';
            } else {
                hideContextMenu();
            }
        }

        function positionContextMenu(x, y) {
            // x and y are event.clientX/Y (viewport coordinates)

            // Get the map container's position relative to the viewport
            const containerRect = mapContainer.getBoundingClientRect();

            // Calculate the menu's desired position relative to the container's top-left corner
            // Subtract container's top/left from the mouse's viewport coordinates
            const menuX = x - containerRect.left;
            const menuY = y - containerRect.top;

            // Apply the calculated coordinates relative to the container
            iconContextMenu.style.left = `${menuX}px`;
            iconContextMenu.style.top = `${menuY}px`;
            iconContextMenu.style.display = 'block'; // Make it visible
            console.log(`Positioning context menu at (${menuX}, ${menuY}) relative to container.`); // Log position
        }

        function hideContextMenu() {
            iconContextMenu.style.display = 'none';
            selectedIconForContextMenu = null;
        }

        function handleContextMenuClick(event) {
            if (!selectedIconForContextMenu) return;

            const action = event.target.id;
            let needsDraw = false; // Flag if we need to redraw
            const index = iconsOnMap.findIndex(icon => icon.id === selectedIconForContextMenu.id); // Find index once

            if (index === -1) { // Safety check if icon was somehow removed
                hideContextMenu();
                return;
            }

            if (action === 'ctxMove') {
                // Initiate a drag from context menu (optional, drag is default)
                isDraggingIcon = true;
                draggedIcon = { ...selectedIconForContextMenu }; // Clone
                const iconScreenPos = gridToScreen(selectedIconForContextMenu.gridX, selectedIconForContextMenu.gridY);
                // Estimate offset if needed, or just let next mouse move handle it
                draggedIcon.offsetX = 15; // Placeholder offset
                draggedIcon.offsetY = 15;
                draggedIcon.isPaletteIcon = false;
                iconsOnMap = iconsOnMap.filter(icon => icon.id !== selectedIconForContextMenu.id); // Remove from map
                canvas.style.cursor = 'grabbing';
                // Note: User needs to mousedown+drag after this to actually move

            } else if (action === 'ctxMarkDead') {
                iconsOnMap[index].isDead = !iconsOnMap[index].isDead;
                // Update the actual icon in the array
                needsDraw = true;
            } else if (action === 'ctxRemove') {
                iconsOnMap.splice(index, 1); // Use splice for efficiency
                needsDraw = true;
            }
            if (action === 'ctxSetSmall') { // Set to Small (Visual) 1x1
                if (iconsOnMap[index].size !== 1 || iconsOnMap[index].creatureSizeCategory !== 'Small') {
                    iconsOnMap[index].size = 1; // Still occupies 1x1 grid
                    iconsOnMap[index].creatureSizeCategory = 'Small';
                    needsDraw = true;
                }
             } else if (action === 'ctxSetMedium') { // Set to Medium 1x1
                 if (iconsOnMap[index].size !== 1 || iconsOnMap[index].creatureSizeCategory !== 'Medium') {
                     iconsOnMap[index].size = 1; 
                     iconsOnMap[index].creatureSizeCategory = 'Medium';
                     needsDraw = true;
                 }
             } else if (action === 'ctxSetLarge') { // Set to Large 2x2
                 if (iconsOnMap[index].size !== 2 || iconsOnMap[index].creatureSizeCategory !== 'Large') {
                     iconsOnMap[index].size = 2;
                     iconsOnMap[index].creatureSizeCategory = 'Large'; // Assume Large visual
                     needsDraw = true;
                 }
             } else if (action === 'ctxSetHuge') { // Set to Huge 3x3
                 if (iconsOnMap[index].size !== 3 || iconsOnMap[index].creatureSizeCategory !== 'Huge') {
                     iconsOnMap[index].size = 3;
                     iconsOnMap[index].creatureSizeCategory = 'Huge';
                     needsDraw = true;
                 }
             } else if (action === 'ctxSetGarg') { // Set to Gargantuan 4x4
                 if (iconsOnMap[index].size !== 4 || iconsOnMap[index].creatureSizeCategory !== 'Gargantuan') {
                     iconsOnMap[index].size = 4;
                     iconsOnMap[index].creatureSizeCategory = 'Gargantuan';
                     needsDraw = true;
                 }
             }
            // --- Handle Rotation Changes ---
            else if (action === 'ctxRotateCW') {
                iconsOnMap[index].iconRotation = (iconsOnMap[index].iconRotation + 90) % 360;
                needsDraw = true;
            } else if (action === 'ctxRotateCCW') {
                iconsOnMap[index].iconRotation = (iconsOnMap[index].iconRotation - 90 + 360) % 360;
                needsDraw = true;
            }
            hideContextMenu(); // Hide menu after any action
            if (needsDraw) {
                draw(); // Redraw only if something changed
            }
        }

        // --- Drawing Functions ---

        function draw() {
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (mapImage) {
                ctx.save(); // Save context state before map transforms

                // --- Apply Map Transformations ---
                ctx.translate(panOffset.x, panOffset.y); // Pan
                ctx.scale(zoom, zoom); // Zoom

                // Map Rotation
                const mapCenterX = mapImage.width / 2;
                const mapCenterY = mapImage.height / 2;
                ctx.translate(mapCenterX, mapCenterY);
                ctx.rotate(currentRotation * Math.PI / 180);
                ctx.translate(-mapCenterX, -mapCenterY);
                // --- End Map Transformations ---

                // Draw Map Image
                ctx.drawImage(mapImage, 0, 0);

                // Draw Grid
                drawGrid();

                // Draw Icons
                drawIcons();

                // Restore context state (removes map transforms)
                ctx.restore();


                // --- Draw Temporary Dragging Icon (in SCREEN coordinates) ---
                 if (isDraggingIcon && draggedIcon && !draggedIcon.isPaletteIcon) {
                    const logicalGridSquares = draggedIcon.size || 1;
                    const sizeCategory = draggedIcon.creatureSizeCategory || 'Medium';
                    const rotation = draggedIcon.iconRotation || 0;

                    // --- Calculate Visual Scale for Drag ---
                    let drawScaleFactor = 1.0;
                    if (sizeCategory === 'Small') {
                        drawScaleFactor = 0.5;
                    }
                    const logicalScreenSize = gridSize * logicalGridSquares * zoom; // Grid space size on screen
                    const iconDrawScreenSize = logicalScreenSize * drawScaleFactor;   // Actual drawing size on screen
                    const screenOffset = (logicalScreenSize - iconDrawScreenSize) / 2; // Centering offset on screen
                    const iconDrawX = draggedIcon.x + screenOffset; // Top-left screen pos for scaled drawing
                    const iconDrawY = draggedIcon.y + screenOffset;
                    // --- End Calculation ---

                    let draggedImageSource = draggedIcon.img; // Static image for drag visual

                    if (!draggedImageSource) {
                         console.warn("Could not find static image source for dragged icon.");
                     } else {
                         ctx.save(); // Save state before drawing dragged icon (alpha + local transforms)
                         ctx.globalAlpha = 0.7; // Apply transparency

                         // --- Apply Local Rotation (around visual center in screen space) ---
                         const screenCenterX = iconDrawX + iconDrawScreenSize / 2;
                         const screenCenterY = iconDrawY + iconDrawScreenSize / 2;
                         ctx.translate(screenCenterX, screenCenterY);
                         ctx.rotate(rotation * Math.PI / 180);
                         ctx.translate(-iconDrawScreenSize / 2, -iconDrawScreenSize / 2); // Translate back for drawing at 0,0 local
                         // --- End Local Rotation ---

                         // Draw image at 0,0 local, scaled to iconDrawScreenSize
                         ctx.drawImage(draggedImageSource, 0, 0, iconDrawScreenSize, iconDrawScreenSize);

                         // Restore context to remove local rotation BEFORE drawing overlays
                         ctx.restore();

                         // --- Draw Overlays (Number, Skull) Upright relative to screen ---
                         ctx.save(); // Save state just for overlays
                         ctx.globalAlpha = 0.7; // Re-apply transparency

                         // Instance Number
                         let totalInstancesOfSrc = 1; for (const i of iconsOnMap) { if (i.src === draggedIcon.src) totalInstancesOfSrc++; }
                         if (draggedIcon.instanceNumber && draggedIcon.instanceNumber > 0 && totalInstancesOfSrc > 1) {
                             const fontSize = Math.max(6, Math.min(14, iconDrawScreenSize * 0.3)); // Size based on DRAWN size
                             ctx.font = `bold ${fontSize}px sans-serif`;
                             ctx.textAlign = 'right'; ctx.textBaseline = 'bottom';
                             const textX = iconDrawX + iconDrawScreenSize * 0.95; // Position based on DRAWN pos/size
                             const textY = iconDrawY + iconDrawScreenSize * 0.95;
                             ctx.strokeStyle = 'black'; ctx.fillStyle = 'white'; ctx.lineWidth = 2;
                             ctx.strokeText(draggedIcon.instanceNumber, textX, textY);
                             ctx.fillText(draggedIcon.instanceNumber, textX, textY);
                         }

                         // Skull Overlay
                         if (draggedIcon.isDead) {
                             if (skullImage && skullImage.complete && skullImage.naturalHeight !== 0) {
                                 // Draw skull over the DRAWN area
                                 ctx.drawImage(skullImage, iconDrawX, iconDrawY, iconDrawScreenSize, iconDrawScreenSize);
                             } else {
                                 console.warn("Skull image not ready for dragged icon");
                                 drawDeadMarker(iconDrawX, iconDrawY, iconDrawScreenSize); // Fallback X based on DRAWN size
                             }
                         }
                         ctx.restore(); // Restore after overlays

                     } // End check for valid draggedImageSource
                 } // --- End temporary icon drawing ---

            } else {
                // Placeholder text
                ctx.fillStyle = '#ccc';
                ctx.font = '20px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText("Upload a map image to begin", canvas.width / 2, canvas.height / 2);
            }
        }

        function drawIcons() {
            const iconBaseSize = gridSize; // Renamed for clarity

            // Calculate counts for conditional numbering
            const countsOnMap = {};
            for (const icon of iconsOnMap) {
                countsOnMap[icon.src] = (countsOnMap[icon.src] || 0) + 1;
            }

            iconsOnMap.forEach(icon => {
                // --- Determine Image Source ---
                let imageToDraw = icon.img; // Static fallback (GIF support removed)
                if (!imageToDraw || !imageToDraw.complete || imageToDraw.naturalHeight === 0) {
                     // console.warn(`Static image source not ready for icon ${icon.id} (${icon.src}).`);
                     return; // Skip if static image not ready
                 }
                // --- End Source ---

                // --- Calculate Sizes and Positions ---
                const worldPos = gridToWorld(icon.gridX, icon.gridY);       // Top-left corner in world space
                const logicalGridSize = (icon.size || 1) * iconBaseSize;  // World size of occupied grid space
                const rotation = icon.iconRotation || 0;
                const sizeCategory = icon.creatureSizeCategory || 'Medium';

                let drawScaleFactor = 1.0; // Default: draw full size
                if (sizeCategory === 'Small') {
                    drawScaleFactor = 0.5; // Draw Small creatures at 50% size
                }
                const drawSize = logicalGridSize * drawScaleFactor; // Actual pixel size to draw (in world units)
                const offset = (logicalGridSize - drawSize) / 2;   // Centering offset (in world units)
                const drawX = worldPos.x + offset;                 // Top-left world coordinate for drawing
                const drawY = worldPos.y + offset;
                // --- End Calculations ---

                // --- Apply Local Rotation (around VISUAL center) ---
                 ctx.save();
                 const drawCenterX = drawX + drawSize / 2;
                 const drawCenterY = drawY + drawSize / 2;
                 ctx.translate(drawCenterX, drawCenterY); // Move to visual center
                 ctx.rotate(rotation * Math.PI / 180);     // Rotate
                 ctx.translate(-drawSize / 2, -drawSize / 2); // Move back for drawing at 0,0 local
                 // --- End Rotation ---

                 // --- Draw Image ---
                 try {
                    // Draw the image at (0, 0) in the locally rotated/translated context, scaled to drawSize
                    ctx.drawImage(imageToDraw, 0, 0, drawSize, drawSize);
                 } catch (e) {
                     console.error(`Error drawing static image for icon ${icon.id} (${icon.src}):`, e);
                 }
                 ctx.restore(); // Restore from local rotation transform
                 // --- End Draw Image ---


                 // --- Draw Overlays (Number, Skull) - Position relative to DRAWN area ---
                 const totalInstancesOfSrc = countsOnMap[icon.src] || 0;
                 if (icon.instanceNumber && icon.instanceNumber > 0 && totalInstancesOfSrc > 1) {
                    ctx.save();
                    const fontSize = Math.max(6, Math.min(14, drawSize * 0.3)) / zoom; // Font size based on drawSize
                    ctx.font = `bold ${fontSize}px sans-serif`;
                    ctx.textAlign = 'right'; ctx.textBaseline = 'bottom';
                    // Position relative to DRAWN bottom-right corner (drawX/Y + drawSize)
                    const textX = drawX + drawSize * 0.95;
                    const textY = drawY + drawSize * 0.95;
                    ctx.strokeStyle = 'black'; ctx.fillStyle = 'white'; ctx.lineWidth = 2 / zoom;
                    ctx.strokeText(icon.instanceNumber, textX, textY);
                    ctx.fillText(icon.instanceNumber, textX, textY);
                    ctx.restore();
                 }

                 if (icon.isDead) {
                     if (skullImage && skullImage.complete && skullImage.naturalHeight !== 0) {
                         ctx.save();
                         ctx.globalAlpha = 0.8;
                         // Draw skull over the DRAWN area (drawX/Y, drawSize)
                         ctx.drawImage(skullImage, drawX, drawY, drawSize, drawSize);
                         ctx.restore();
                     } else {
                         console.warn("Skull image not ready...", icon.id);
                         // Draw fallback X over the DRAWN area
                         drawDeadMarkerWorld(drawX, drawY, drawSize);
                     }
                 }
                 // --- End Overlays ---

            }); // End forEach
        } // End drawIcons



        function drawGrid() {
            // --- Check Show Grid Checkbox ---
            if (!showGridCheckbox.checked) {
                return; // Don't draw if checkbox is unchecked
            }
            // --- End Check ---

            if (!mapImage) return; // Don't draw if no map image

            const scaledGridSize = gridSize * zoom;
            // Don't draw if grid squares are too small visually
            if (scaledGridSize < 3) return;

            ctx.save(); // Save the current transform state (includes map pan/zoom/rotation)

            // Grid line style
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)'; // Semi-transparent black
            // Define line width in world space, scale visually with zoom. Min width 1px.
            ctx.lineWidth = Math.max(1 / zoom, 2); // Make base thickness 2px in world coords

            // --- Calculate Grid Offset in World Coordinates ---
            // We need to convert the gridPanOffset (which is in screen pixels)
            // into an offset in the *current rotated and zoomed world space*
            // This is complex because map rotation affects the direction of the offset.

            // --- Simplified Approach (Ignoring Map Rotation for Grid Pan Direction) ---
            // Treats gridPanOffset purely as an offset in the final view, converted back to world units.
            // This will feel correct when the map rotation is 0, but might feel slightly off
            // when the map is rotated (e.g., dragging grid left might move it diagonally on a rotated map).
            const gridOffsetXWorld = (gridPanOffset.x / zoom);
            const gridOffsetYWorld = (gridPanOffset.y / zoom);
            // --- End Simplified Approach ---

            // Calculate the visible range in WORLD coordinates (original map orientation)
            // These are needed to determine which lines fall within the viewport
            const viewTopLeftWorld = screenToWorld(0, 0);
            const viewBottomRightWorld = screenToWorld(canvas.width, canvas.height);

            // Determine the range of grid lines potentially visible, considering the offset
            const firstCol = Math.floor((viewTopLeftWorld.x - gridOffsetXWorld) / gridSize);
            const lastCol = Math.ceil((viewBottomRightWorld.x - gridOffsetXWorld) / gridSize);
            const firstRow = Math.floor((viewTopLeftWorld.y - gridOffsetYWorld) / gridSize);
            const lastRow = Math.ceil((viewBottomRightWorld.y - gridOffsetYWorld) / gridSize);

            ctx.beginPath(); // Start path for all grid lines

            // --- Draw Vertical Lines ---
            for (let col = firstCol; col <= lastCol; col++) {
                 // Calculate the X position of this line in world coordinates, including the offset
                 const x = col * gridSize + gridOffsetXWorld;
                 // Draw the line across the entire height of the map image
                 // (The context's transform clips it to the viewport)
                 // We use the map image dimensions as absolute bounds
                 ctx.moveTo(x, 0); // Start at map top (world y=0)
                 ctx.lineTo(x, mapImage.height); // End at map bottom (world y=height)
            }

            // --- Draw Horizontal Lines ---
            for (let row = firstRow; row <= lastRow; row++) {
                // Calculate the Y position of this line in world coordinates, including the offset
                const y = row * gridSize + gridOffsetYWorld;
                 // Draw the line across the entire width of the map image
                 ctx.moveTo(0, y); // Start at map left (world x=0)
                 ctx.lineTo(mapImage.width, y); // End at map right (world x=width)
            }

            ctx.stroke(); // Draw all the lines added to the path
            ctx.restore(); // Restore the original transform state
        }

        // NEW or ADAPTED function to draw marker in WORLD coordinates
        function drawDeadMarkerWorld(worldX, worldY, worldSize) {
             ctx.save(); // Isolate marker drawing settings
             ctx.strokeStyle = 'red';
             // Make line width consistent regardless of zoom level
             // Line width is defined in world units here
             ctx.lineWidth = Math.max(1, 3 / zoom); // Ensure minimum width of 1px visually
             ctx.beginPath();
             // Calculate offsets relative to worldSize
             const offset = worldSize * 0.1;
             // Line 1: Top-left to bottom-right
             ctx.moveTo(worldX + offset, worldY + offset);
             ctx.lineTo(worldX + worldSize - offset, worldY + worldSize - offset);
             // Line 2: Top-right to bottom-left
             ctx.moveTo(worldX + worldSize - offset, worldY + offset);
             ctx.lineTo(worldX + offset, worldY + worldSize - offset);
             ctx.stroke();
             ctx.restore(); // Restore context state
        }

        // Keep the original drawDeadMarker for the screen-space dragged icon
        function drawDeadMarker(screenX, screenY, size) {
             // Draws marker in screen space
             ctx.save(); // Isolate settings
             ctx.strokeStyle = 'red';
             ctx.lineWidth = 3; // Fixed pixel width for screen drawing
             ctx.beginPath();
             const offset = size * 0.1;
             ctx.moveTo(screenX + offset, screenY + offset);
             ctx.lineTo(screenX + size - offset, screenY + size - offset);
             ctx.moveTo(screenX + size - offset, screenY + offset);
             ctx.lineTo(screenX + offset, screenY + size - offset);
             ctx.stroke();
             ctx.restore();
        }

        // --- Helper Functions ---

        function getMousePos(canvas, event) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
        }

        // Convert screen coordinates (canvas pixels) to world coordinates (map pixels, considering rotation)
                // Convert screen coordinates (canvas pixels) to world coordinates (original map pixels)
                function screenToWorld(screenX, screenY) {
            if (!mapImage) return { x: 0, y: 0 };

            // 1. Undo Pan and Zoom
            let x = (screenX - panOffset.x) / zoom;
            let y = (screenY - panOffset.y) / zoom;

            // Point (x, y) is now in the coordinate system *after* rotation was applied in draw()

            // 2. Undo Rotation (around map center)
            const mapCenterX = mapImage.width / 2;
            const mapCenterY = mapImage.height / 2;
            const angleRad = -currentRotation * Math.PI / 180; // Inverse angle

            // Translate point so map center becomes the origin
            x -= mapCenterX;
            y -= mapCenterY;

            // Apply inverse rotation
            const rotatedX = x * Math.cos(angleRad) - y * Math.sin(angleRad);
            const rotatedY = x * Math.sin(angleRad) + y * Math.cos(angleRad);

            // Translate back to get original world coordinates
            const finalWorldX = rotatedX + mapCenterX;
            const finalWorldY = rotatedY + mapCenterY;

            return { x: finalWorldX, y: finalWorldY };
        }

        // Convert world coordinates (original map pixels) to screen coordinates (canvas pixels)
        function worldToScreen(worldX, worldY) {
             if (!mapImage) return { x: 0, y: 0 };

             // 1. Apply Rotation (around map center)
             const mapCenterX = mapImage.width / 2;
             const mapCenterY = mapImage.height / 2;
             const angleRad = currentRotation * Math.PI / 180; // Forward angle

             // Translate point so map center is the origin
             let x = worldX - mapCenterX;
             let y = worldY - mapCenterY;

             // Apply forward rotation
             const rotatedX = x * Math.cos(angleRad) - y * Math.sin(angleRad);
             const rotatedY = x * Math.sin(angleRad) + y * Math.cos(angleRad);

             // Translate back, putting point in the rotated coordinate space relative to top-left
             x = rotatedX + mapCenterX;
             y = rotatedY + mapCenterY;

             // Point (x,y) is now ready for zoom and pan

             // 2. Apply Zoom and Pan
             const screenX = (x * zoom) + panOffset.x;
             const screenY = (y * zoom) + panOffset.y;

             return { x: screenX, y: screenY };
        }

        // Convert screen coordinates to grid cell coordinates {gridX, gridY}
        function screenToGrid(screenX, screenY) {
            if (!mapImage) return { gridX: null, gridY: null };

            const worldPos = screenToWorld(screenX, screenY); // Uses the updated screenToWorld

            const gridOffsetXWorld = (gridPanOffset.x / zoom);
            const gridOffsetYWorld = (gridPanOffset.y / zoom);
            const worldXRelativeToGrid = worldPos.x - gridOffsetXWorld;
            const worldYRelativeToGrid = worldPos.y - gridOffsetYWorld;

            // Check if world position is within the *original* map image bounds
            // (Grid is defined relative to the original image data)
            if (worldPos.x < 0 || worldPos.x >= mapImage.width || worldPos.y < 0 || worldPos.y >= mapImage.height) {
                console.log("Screen point corresponds to outside map bounds", worldPos);
                // Return null if click is outside the actual map image area,
                // even if it's within the visual rotated bounds on canvas.
                // This prevents placing icons in empty space created by rotating.
                return { gridX: null, gridY: null };
            }

            // Calculate grid indices based on position relative to grid origin
            const gridX = Math.floor(worldXRelativeToGrid / gridSize);
            const gridY = Math.floor(worldYRelativeToGrid / gridSize);

            // Additional check: ensure calculated grid cell is within the map's grid dimensions
            const maxGridX = Math.floor(mapImage.width / gridSize);
            const maxGridY = Math.floor(mapImage.height / gridSize);
            if (gridX < 0 || gridY < 0 || gridX >= maxGridX || gridY >= maxGridY ) {
                console.log("Calculated grid cell outside map grid dimensions", {gridX, gridY});
                // return { gridX: null, gridY: null }; // Be stricter? Or allow partials? Let's allow for now.
            }


            return { gridX, gridY };
        }

        // Convert grid cell coordinates {gridX, gridY} to world coordinates (top-left corner of cell on original map)
        function gridToWorld(gridX, gridY) {
            // --- Adjust world position by the grid's offset ---
            const gridOffsetXWorld = (gridPanOffset.x / zoom); // Simplified
            const gridOffsetYWorld = (gridPanOffset.y / zoom); // Simplified

            return {
                x: gridX * gridSize + gridOffsetXWorld,
                y: gridY * gridSize + gridOffsetYWorld
            };
        }


         // Convert grid cell coordinates {gridX, gridY} to screen coordinates (top-left corner, considering rotation/zoom/pan)
         function gridToScreen(gridX, gridY) {
            const worldPos = gridToWorld(gridX, gridY); // Get world pos (original map)
            return worldToScreen(worldPos.x, worldPos.y); // Convert that to screen pos (uses updated worldToScreen)
         }


        function getIconAtScreenPos(screenX, screenY) {
            if (!mapImage || iconsOnMap.length === 0) return null;

            const worldPos = screenToWorld(screenX, screenY); // Correct: Click pos in world coords

            // Iterate icons in reverse (topmost first)
            for (let i = iconsOnMap.length - 1; i >= 0; i--) {
                const icon = iconsOnMap[i];
                const iconSize = icon.size || 1; // Logical grid size (1, 2, 3, 4)

                // --- PROBLEM AREA ---
                // Calculate icon's bounding box in world coordinates
                // This calculation DOES NOT currently account for the gridPanOffset!
                // It assumes the icon's top-left world position is simply gridX * gridSize.
                const iconWorldX_Incorrect = icon.gridX * gridSize;
                const iconWorldY_Incorrect = icon.gridY * gridSize;

                // --- CORRECTED CALCULATION ---
                // We need the *actual* top-left world position using gridToWorld, which includes the offset
                const iconTopLeftWorld = gridToWorld(icon.gridX, icon.gridY);
                const iconWorldX = iconTopLeftWorld.x;
                const iconWorldY = iconTopLeftWorld.y;
                // --- END CORRECTION ---

                const iconWorldWidth = iconSize * gridSize;
                const iconWorldHeight = iconSize * gridSize;

                // Check if the click's world position is within the icon's *actual* world bounds
                if (
                    worldPos.x >= iconWorldX &&
                    worldPos.x < iconWorldX + iconWorldWidth &&
                    worldPos.y >= iconWorldY &&
                    worldPos.y < iconWorldY + iconWorldHeight
                ) {
                    console.log("getIconAtScreenPos: Found icon:", icon.id); // Add log
                    return icon; // Found the icon
                }
            }
            console.log("getIconAtScreenPos: No icon found at", worldPos); // Add log
            return null; // No icon found at this position
        }

        // --- Start the App ---
            // --- Start the App AFTER the DOM is fully loaded ---
        document.addEventListener('DOMContentLoaded', (event) => {
            console.log("DOM fully loaded and parsed");
            initialize(); // Call initialize only now
        });
        // --- End App Start ---

    </script>

</body>
</html>